# EasyAIoT 架构分析与 TASK 模块开发路线图

## 📊 一、当前系统架构分析

### 1.1 模块架构总览

```
┌─────────────────────────────────────────────────────────────┐
│                    WEB 模块 (Vue.js)                        │
│          前端UI、任务创建、模型管理、视频墙展示              │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTP REST API
    ┌─────────────────┼───────────────────┐
    │                 │                   │
┌───▼────────┐  ┌────▼──────┐  ┌────────▼───────┐
│  DEVICE    │  │   VIDEO   │  │      AI        │
│  (Java)    │  │  (Python) │  │   (Python)     │
│            │  │           │  │                │
│ 设备管理   │  │ 摄像头    │  │ 模型训练       │
│ Node-RED   │  │ FFmpeg    │  │ 数据标注       │
│ 规则引擎   │  │ 流转发    │  │ 推理任务管理   │
└────────────┘  └───────────┘  └────────────────┘
                      │
                      │ (当前缺失连接)
                      │
            ┌─────────▼──────────┐
            │   TASK (C++)       │
            │                    │
            │ ❌ 独立运行        │
            │ ❌ 无HTTP API      │
            │ ❌ 无动态调度      │
            │ ✅ 高性能推理      │
            │ ✅ RTMP推流        │
            │ ✅ 报警回调        │
            └────────────────────┘
```

---

## 🔍 二、关键问题分析

### 2.1 DEVICE 模块如何调度 TASK？

**答案：目前不调度！**

#### 当前架构的事实：

1. **DEVICE 模块职责**：
   - 设备（摄像头）注册和管理
   - Node-RED 规则引擎（报警规则配置）
   - 接收来自其他模块的报警回调
   - 服务注册中心（Nacos）

2. **AI 模块的推理方式**：
   - 使用 **Python + YOLO** 进行推理
   - 通过 REST API 管理推理任务
   - 任务信息存储在 PostgreSQL 数据库
   - 前端可以通过API动态创建/查询/停止任务
   
   ```python
   # AI/app/blueprints/inference_task.py
   POST /model/inference_task/create      # 创建任务
   POST /model/inference_task/execute/<task_id>  # 执行任务
   GET  /model/inference_task/list        # 查询任务列表
   PUT  /model/inference_task/update/<task_id>   # 更新任务
   DELETE /model/inference_task/<task_id> # 删除任务
   ```

3. **TASK 模块的现状**：
   ```bash
   # 完全独立运行，手动启动
   .\TASK.exe config\test.ini
   
   # 配置文件是静态的INI格式
   # 没有HTTP API接口
   # 无法被云端动态管理
   ```

#### 为什么会这样？

根据开源项目的README描述：

> "EasyAIoT其实不是一个项目，而是五个项目。"
> "假如说你在一个受限的设备上（比如RK3588），你只需要拿出其中某个项目就可以独立部署"

**设计初衷**：
- TASK 模块设计为**独立边缘推理引擎**
- 可以脱离云端平台独立运行
- 但**缺少了云边协同的管理接口**

---

### 2.2 模型管理流程分析

#### 当前模型管理架构：

```
┌──────────────────────────────────────────────────────────┐
│                    云端模型管理流程                       │
└──────────────────────────────────────────────────────────┘

1. 数据标注 (WEB)
   └─> 使用大模型自动标注 + 人工校验
        │
2. 模型训练 (AI模块)
   └─> Python + Ultralytics (YOLO)
   └─> 训练任务记录在PostgreSQL
   └─> 模型文件存储在MinIO
        │
3. 模型导出 (AI模块)
   └─> 导出为ONNX/TorchScript/TensorRT等格式
   └─> 存储在MinIO对象存储
        │
4. 模型推理 (两种方式)
   
   方式A：云端Python推理 ✅（当前使用）
   └─> AI模块的InferenceService
   └─> 使用REST API管理
   └─> 数据库记录任务状态
   
   方式B：边缘C++推理 ❌（未集成）
   └─> TASK模块
   └─> 独立运行，无法被云端管理
   └─> 配置文件静态，无动态模型加载
```

#### 模型下发流程（目前缺失）：

```
云端训练好的模型 (MinIO)
        │
        │ ❌ 没有实现
        ▼
边缘TASK模块
        │
        │ ❌ TASK无法从MinIO下载模型
        │ ❌ TASK无法接收云端的模型更新通知
        ▼
静态INI配置
model_path=F:/local/path/yolov11n.onnx
```

---

## 🎯 三、你的场景需求分析

### 3.1 场景特征

- **部署方式**：边缘部署（非云端集中式）
- **摄像头数量**：50路并发
- **网络要求**：需要离线运行
- **性能需求**：C++高性能推理

### 3.2 架构痛点

| 问题 | 当前状态 | 你的需求 |
|------|---------|---------|
| 任务调度 | 手动启动TASK.exe | 需要云端或本地管理平台动态调度 |
| 多路并发 | 需要启动50个TASK进程 | 需要统一管理器管理50路任务 |
| 模型管理 | 静态INI配置 | 需要支持模型热更新、多模型切换 |
| 配置管理 | 手动编辑INI文件 | 需要数据库驱动或API驱动 |
| 监控告警 | 只有HTTP回调 | 需要状态上报、心跳检测 |
| 视频流管理 | 每个TASK独立推流 | 需要统一视频墙展示 |

---

## 🛠️ 四、开发路线图

### 阶段1：TaskManager 进程管理器（核心）⭐⭐⭐⭐⭐

**目标**：让 TASK 模块支持云边协同管理

#### 1.1 创建 HTTP API 服务

```cpp
// TASK/src/TaskManager.h
class TaskManager {
public:
    // HTTP API接口
    void startServer(int port);
    
    // 任务管理API
    std::string createTask(const json& config);    // POST /api/tasks
    bool startTask(const std::string& task_id);    // POST /api/tasks/{id}/start
    bool stopTask(const std::string& task_id);     // POST /api/tasks/{id}/stop
    json getTaskStatus(const std::string& task_id);// GET  /api/tasks/{id}
    json listTasks();                               // GET  /api/tasks
    bool deleteTask(const std::string& task_id);   // DELETE /api/tasks/{id}
    
    // 心跳与状态上报
    void reportStatus();                            // 定时向云端上报
    
private:
    std::map<std::string, std::shared_ptr<Detech>> tasks_;
    httplib::Server server_;
};
```

#### 1.2 任务配置格式（JSON替代INI）

```json
{
  "task_id": "camera_001",
  "video": {
    "rtsp_url": "rtsp://192.168.1.64:554/stream",
    "rtmp_url": "rtmp://localhost:1935/live/camera_001",
    "width": 1280,
    "height": 720,
    "fps": 25
  },
  "ai": {
    "enable": true,
    "model_path": "/models/yolov11n.onnx",
    "threads": 1
  },
  "alarm": {
    "hook_url": "http://192.168.1.10:1880/api/alarm/callback",
    "confidence_threshold": 0.5,
    "cooldown_time": 5
  }
}
```

#### 1.3 TaskManager 部署架构

```
┌─────────────────────────────────────────────────────┐
│               边缘服务器（一台物理机）                │
├─────────────────────────────────────────────────────┤
│                                                     │
│  TaskManager (HTTP :8080)                          │
│  ├─ Task-camera_001 (RTSP → AI → RTMP)            │
│  ├─ Task-camera_002 (RTSP → AI → RTMP)            │
│  ├─ Task-camera_003 (RTSP → AI → RTMP)            │
│  ├─ ...                                             │
│  └─ Task-camera_050 (RTSP → AI → RTMP)            │
│                                                     │
│  ZLMediaKit (RTMP服务器 :1935)                     │
│  ├─ Stream: live/camera_001                        │
│  ├─ Stream: live/camera_002                        │
│  └─ ...                                            │
│                                                     │
│  PostgreSQL (本地数据库)                           │
│  └─ 存储任务配置、模型信息、报警记录               │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

### 阶段2：模型动态管理 ⭐⭐⭐⭐

**目标**：支持模型热更新和多模型切换

#### 2.1 模型管理API

```cpp
// TaskManager HTTP API扩展
POST   /api/models/upload        # 上传模型文件
GET    /api/models               # 列出所有可用模型
POST   /api/tasks/{id}/model     # 切换任务使用的模型
DELETE /api/models/{model_id}    # 删除模型
```

#### 2.2 模型存储结构

```
/models/
  ├── yolov11n.onnx           # 轻量模型（通用）
  ├── yolov11s.onnx           # 小模型
  ├── helmet_detection.onnx   # 安全帽检测专用模型
  ├── fire_smoke.onnx         # 火焰烟雾检测
  └── classes/
      ├── coco.names           # COCO类别
      ├── helmet.names         # 安全帽类别
      └── fire.names           # 火焰类别
```

#### 2.3 模型热更新流程

```
1. 云端训练新模型
   └─> 导出ONNX格式
   └─> 存储到MinIO

2. 通过TaskManager API上传模型
   └─> POST /api/models/upload
   └─> 边缘TaskManager保存到本地/models/

3. 更新任务使用的模型
   └─> POST /api/tasks/{id}/model {"model_path": "new_model.onnx"}
   └─> TaskManager停止任务 → 重新加载模型 → 重启任务
```

---

### 阶段3：报警区域检测（ROI）⭐⭐⭐

**目标**：只在指定区域触发报警

#### 3.1 区域配置格式

```json
{
  "task_id": "camera_001",
  "alarm": {
    "enable": true,
    "confidence_threshold": 0.5,
    "regions": [
      {
        "name": "入口区域",
        "polygon": [
          [100, 200],
          [500, 200],
          [500, 600],
          [100, 600]
        ],
        "classes": ["person"],  // 只检测人
        "action": "alert"
      },
      {
        "name": "禁区",
        "polygon": [
          [600, 100],
          [900, 100],
          [900, 400],
          [600, 400]
        ],
        "classes": ["person", "vehicle"],
        "action": "alert"
      }
    ]
  }
}
```

#### 3.2 实现步骤

1. 定义 `AlarmRegion` 结构体
2. 实现点在多边形内判断算法（射线法）
3. 在检测结果过滤时应用区域筛选
4. 前端绘制区域工具（已有基础）

---

### 阶段4：前端集成（视频墙）⭐⭐⭐⭐

**目标**：统一展示50路视频流

#### 4.1 视频墙架构

```vue
<!-- WEB/src/views/monitor/VideoWall.vue -->
<template>
  <div class="video-wall">
    <div v-for="camera in cameras" :key="camera.id" class="video-item">
      <video-player
        :stream-url="`http://localhost/live/${camera.id}.flv`"
        :camera-name="camera.name"
        @alarm="handleAlarm"
      />
      <div class="camera-status">
        <Tag :color="camera.status === 'active' ? 'green' : 'red'">
          {{ camera.status }}
        </Tag>
      </div>
    </div>
  </div>
</template>
```

#### 4.2 API集成

```typescript
// WEB/src/api/task/index.ts
export const taskApi = {
  // 任务管理
  createTask: (config) => post('/edge/tasks', config),
  listTasks: () => get('/edge/tasks'),
  startTask: (id) => post(`/edge/tasks/${id}/start`),
  stopTask: (id) => post(`/edge/tasks/${id}/stop`),
  getTaskStatus: (id) => get(`/edge/tasks/${id}/status`),
  
  // 模型管理
  uploadModel: (file) => upload('/edge/models', file),
  listModels: () => get('/edge/models'),
  switchModel: (taskId, modelId) => post(`/edge/tasks/${taskId}/model`, { modelId })
}
```

---

### 阶段5：离线部署优化 ⭐⭐⭐

**目标**：支持完全离线运行

#### 5.1 本地化数据库

```sql
-- 使用SQLite替代PostgreSQL（可选）
CREATE TABLE tasks (
    id TEXT PRIMARY KEY,
    config TEXT NOT NULL,
    status TEXT DEFAULT 'stopped',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE models (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    path TEXT NOT NULL,
    version TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE alarms (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    class TEXT,
    confidence REAL,
    image_path TEXT,
    FOREIGN KEY (task_id) REFERENCES tasks(id)
);
```

#### 5.2 本地Web控制台

```
┌───────────────────────────────────────┐
│      TaskManager Local Console        │
│      http://192.168.1.100:8080        │
├───────────────────────────────────────┤
│                                       │
│  📹 视频墙 (50路实时视频)             │
│  ⚙️  任务管理 (启动/停止/配置)        │
│  🤖 模型管理 (上传/切换)              │
│  🚨 报警记录 (历史查询)               │
│  📊 性能监控 (CPU/内存/推理耗时)      │
│                                       │
└───────────────────────────────────────┘
```

---

## 📐 五、50路摄像头部署架构设计

### 5.1 单机部署方案（推荐）

**硬件配置建议**：
- CPU: Intel i7-12700 (12核) 或 AMD Ryzen 7 5800X
- 内存: 64GB DDR4
- GPU: NVIDIA RTX 3060 (12GB显存) 或 RTX 4060
- 存储: 2TB NVMe SSD
- 网络: 双千兆网卡（一个接摄像头，一个接外网）

**软件架构**：

```
┌─────────────────────────────────────────────────────────────┐
│                    边缘AI推理服务器                         │
│                 (192.168.1.100 - 内网IP)                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  TaskManager (:8080)                                        │
│  ├─ 管理50个推理任务                                        │
│  ├─ HTTP API (本地Web控制台)                               │
│  └─ SQLite本地数据库                                        │
│                                                             │
│  ZLMediaKit (:1935/:80)                                     │
│  └─ 接收50路RTMP推流                                        │
│                                                             │
│  TASK Processes (50个实例)                                  │
│  ├─ camera_001: RTSP → YOLOv11 → RTMP (:1.5GB内存)        │
│  ├─ camera_002: RTSP → YOLOv11 → RTMP (:1.5GB内存)        │
│  ├─ ...                                                     │
│  └─ camera_050: RTSP → YOLOv11 → RTMP (:1.5GB内存)        │
│                                                             │
│  资源占用估算:                                              │
│  ├─ 内存: 50 × 1.5GB = 75GB (建议64GB + 交换)            │
│  ├─ CPU: 50路 @ 25fps,每路10-15% CPU = 需要12核+         │
│  └─ 带宽: 50 × 4Mbps (RTSP) + 50 × 2Mbps (RTMP) = 300Mbps │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 多机分布式方案（备选）

如果单机性能不足，可以部署2-3台服务器：

```
服务器1 (192.168.1.101) - 20路摄像头
服务器2 (192.168.1.102) - 20路摄像头
服务器3 (192.168.1.103) - 10路摄像头

┌─────────────────────────────────────────┐
│       主控服务器 (192.168.1.100)        │
│                                         │
│  TaskManager Master (:8080)             │
│  ├─ 负载均衡                            │
│  ├─ 任务调度                            │
│  └─ 统一Web控制台                       │
│                                         │
│  ZLMediaKit (:1935)                     │
│  └─ 汇聚所有视频流                      │
└─────────────────────────────────────────┘
           │
    ┌──────┼──────┐
    │      │      │
┌───▼──┐ ┌─▼────┐ ┌─▼────┐
│ 101  │ │ 102  │ │ 103  │
│ 20路 │ │ 20路 │ │ 10路 │
└──────┘ └──────┘ └──────┘
```

---

## 🚀 六、立即行动计划

### Week 1-2: TaskManager核心框架
1. ✅ 集成 cpp-httplib（HTTP服务器）
2. ✅ 实现任务创建/启动/停止API
3. ✅ 实现任务配置的JSON解析
4. ✅ 多任务并发管理

### Week 3: 模型管理
1. ✅ 实现模型上传API
2. ✅ 实现模型热更新机制
3. ✅ 支持多模型切换

### Week 4: 报警区域
1. ✅ ROI多边形定义
2. ✅ 点在多边形判断算法
3. ✅ 集成到报警逻辑

### Week 5-6: 前端集成
1. ✅ 视频墙UI组件
2. ✅ TaskManager API对接
3. ✅ 实时状态监控

### Week 7: 性能优化
1. ✅ 内存优化（减少泄漏）
2. ✅ 多线程优化
3. ✅ GPU加速（可选）

### Week 8: 测试与部署
1. ✅ 50路并发压力测试
2. ✅ 离线部署验证
3. ✅ 文档完善

---

## 📝 七、关键技术决策

### 7.1 为什么需要 TaskManager？

| 决策 | 理由 |
|------|------|
| 统一进程管理 | 50路摄像头不能手动启动50个TASK.exe |
| HTTP API | 方便前端/云端远程管理 |
| JSON配置 | 比INI更灵活，支持动态更新 |
| 心跳上报 | 监控任务健康状态 |

### 7.2 为什么不用云端Python推理？

| 对比项 | Python (AI模块) | C++ (TASK模块) |
|-------|-----------------|----------------|
| 性能 | 较慢 | ✅ 快3-5倍 |
| 内存 | 每路~3GB | ✅ 每路~1.5GB |
| 延迟 | 2-3秒 | ✅ <1秒 |
| 并发 | 10路即吃力 | ✅ 50路无压力 |
| 部署 | 需要Python环境 | ✅ 单个exe |
| 离线 | 需要网络 | ✅ 完全离线 |

**结论**：边缘50路并发，必须用C++ TASK模块！

---

## 🎯 八、你的下一步

### 立即可以做的：

1. **确认硬件配置**
   - 你的边缘服务器硬件是什么？
   - 能不能支持50路并发？

2. **确认网络拓扑**
   - 50个摄像头的IP段是什么？
   - 是否需要连接外网？

3. **选择开发方案**
   - 方案A：我帮你完整实现TaskManager（推荐）
   - 方案B：你自己实现，我提供指导

### 我可以立即帮你做的：

1. ✅ 实现TaskManager HTTP API
2. ✅ 实现多任务管理器
3. ✅ 实现报警区域检测
4. ✅ 实现模型热更新
5. ✅ 提供完整的部署文档

---

## 💬 现在请告诉我：

1. **你想先做哪个？**
   - A. TaskManager（让TASK支持API管理）⭐⭐⭐⭐⭐
   - B. 报警区域检测（ROI过滤）⭐⭐⭐
   - C. 前端视频墙集成⭐⭐⭐⭐
   - D. 模型管理优化⭐⭐⭐⭐

2. **你的边缘服务器配置是什么？**
   - CPU型号？
   - 内存大小？
   - 是否有GPU？

3. **摄像头信息？**
   - 分辨率？
   - 帧率？
   - IP地址段？

**我建议先做 TaskManager（选项A），这是云边协同的核心，也是50路并发的基础！**

要开始吗？🚀


## 📊 一、当前系统架构分析

### 1.1 模块架构总览

```
┌─────────────────────────────────────────────────────────────┐
│                    WEB 模块 (Vue.js)                        │
│          前端UI、任务创建、模型管理、视频墙展示              │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTP REST API
    ┌─────────────────┼───────────────────┐
    │                 │                   │
┌───▼────────┐  ┌────▼──────┐  ┌────────▼───────┐
│  DEVICE    │  │   VIDEO   │  │      AI        │
│  (Java)    │  │  (Python) │  │   (Python)     │
│            │  │           │  │                │
│ 设备管理   │  │ 摄像头    │  │ 模型训练       │
│ Node-RED   │  │ FFmpeg    │  │ 数据标注       │
│ 规则引擎   │  │ 流转发    │  │ 推理任务管理   │
└────────────┘  └───────────┘  └────────────────┘
                      │
                      │ (当前缺失连接)
                      │
            ┌─────────▼──────────┐
            │   TASK (C++)       │
            │                    │
            │ ❌ 独立运行        │
            │ ❌ 无HTTP API      │
            │ ❌ 无动态调度      │
            │ ✅ 高性能推理      │
            │ ✅ RTMP推流        │
            │ ✅ 报警回调        │
            └────────────────────┘
```

---

## 🔍 二、关键问题分析

### 2.1 DEVICE 模块如何调度 TASK？

**答案：目前不调度！**

#### 当前架构的事实：

1. **DEVICE 模块职责**：
   - 设备（摄像头）注册和管理
   - Node-RED 规则引擎（报警规则配置）
   - 接收来自其他模块的报警回调
   - 服务注册中心（Nacos）

2. **AI 模块的推理方式**：
   - 使用 **Python + YOLO** 进行推理
   - 通过 REST API 管理推理任务
   - 任务信息存储在 PostgreSQL 数据库
   - 前端可以通过API动态创建/查询/停止任务
   
   ```python
   # AI/app/blueprints/inference_task.py
   POST /model/inference_task/create      # 创建任务
   POST /model/inference_task/execute/<task_id>  # 执行任务
   GET  /model/inference_task/list        # 查询任务列表
   PUT  /model/inference_task/update/<task_id>   # 更新任务
   DELETE /model/inference_task/<task_id> # 删除任务
   ```

3. **TASK 模块的现状**：
   ```bash
   # 完全独立运行，手动启动
   .\TASK.exe config\test.ini
   
   # 配置文件是静态的INI格式
   # 没有HTTP API接口
   # 无法被云端动态管理
   ```

#### 为什么会这样？

根据开源项目的README描述：

> "EasyAIoT其实不是一个项目，而是五个项目。"
> "假如说你在一个受限的设备上（比如RK3588），你只需要拿出其中某个项目就可以独立部署"

**设计初衷**：
- TASK 模块设计为**独立边缘推理引擎**
- 可以脱离云端平台独立运行
- 但**缺少了云边协同的管理接口**

---

### 2.2 模型管理流程分析

#### 当前模型管理架构：

```
┌──────────────────────────────────────────────────────────┐
│                    云端模型管理流程                       │
└──────────────────────────────────────────────────────────┘

1. 数据标注 (WEB)
   └─> 使用大模型自动标注 + 人工校验
        │
2. 模型训练 (AI模块)
   └─> Python + Ultralytics (YOLO)
   └─> 训练任务记录在PostgreSQL
   └─> 模型文件存储在MinIO
        │
3. 模型导出 (AI模块)
   └─> 导出为ONNX/TorchScript/TensorRT等格式
   └─> 存储在MinIO对象存储
        │
4. 模型推理 (两种方式)
   
   方式A：云端Python推理 ✅（当前使用）
   └─> AI模块的InferenceService
   └─> 使用REST API管理
   └─> 数据库记录任务状态
   
   方式B：边缘C++推理 ❌（未集成）
   └─> TASK模块
   └─> 独立运行，无法被云端管理
   └─> 配置文件静态，无动态模型加载
```

#### 模型下发流程（目前缺失）：

```
云端训练好的模型 (MinIO)
        │
        │ ❌ 没有实现
        ▼
边缘TASK模块
        │
        │ ❌ TASK无法从MinIO下载模型
        │ ❌ TASK无法接收云端的模型更新通知
        ▼
静态INI配置
model_path=F:/local/path/yolov11n.onnx
```

---

## 🎯 三、你的场景需求分析

### 3.1 场景特征

- **部署方式**：边缘部署（非云端集中式）
- **摄像头数量**：50路并发
- **网络要求**：需要离线运行
- **性能需求**：C++高性能推理

### 3.2 架构痛点

| 问题 | 当前状态 | 你的需求 |
|------|---------|---------|
| 任务调度 | 手动启动TASK.exe | 需要云端或本地管理平台动态调度 |
| 多路并发 | 需要启动50个TASK进程 | 需要统一管理器管理50路任务 |
| 模型管理 | 静态INI配置 | 需要支持模型热更新、多模型切换 |
| 配置管理 | 手动编辑INI文件 | 需要数据库驱动或API驱动 |
| 监控告警 | 只有HTTP回调 | 需要状态上报、心跳检测 |
| 视频流管理 | 每个TASK独立推流 | 需要统一视频墙展示 |

---

## 🛠️ 四、开发路线图

### 阶段1：TaskManager 进程管理器（核心）⭐⭐⭐⭐⭐

**目标**：让 TASK 模块支持云边协同管理

#### 1.1 创建 HTTP API 服务

```cpp
// TASK/src/TaskManager.h
class TaskManager {
public:
    // HTTP API接口
    void startServer(int port);
    
    // 任务管理API
    std::string createTask(const json& config);    // POST /api/tasks
    bool startTask(const std::string& task_id);    // POST /api/tasks/{id}/start
    bool stopTask(const std::string& task_id);     // POST /api/tasks/{id}/stop
    json getTaskStatus(const std::string& task_id);// GET  /api/tasks/{id}
    json listTasks();                               // GET  /api/tasks
    bool deleteTask(const std::string& task_id);   // DELETE /api/tasks/{id}
    
    // 心跳与状态上报
    void reportStatus();                            // 定时向云端上报
    
private:
    std::map<std::string, std::shared_ptr<Detech>> tasks_;
    httplib::Server server_;
};
```

#### 1.2 任务配置格式（JSON替代INI）

```json
{
  "task_id": "camera_001",
  "video": {
    "rtsp_url": "rtsp://192.168.1.64:554/stream",
    "rtmp_url": "rtmp://localhost:1935/live/camera_001",
    "width": 1280,
    "height": 720,
    "fps": 25
  },
  "ai": {
    "enable": true,
    "model_path": "/models/yolov11n.onnx",
    "threads": 1
  },
  "alarm": {
    "hook_url": "http://192.168.1.10:1880/api/alarm/callback",
    "confidence_threshold": 0.5,
    "cooldown_time": 5
  }
}
```

#### 1.3 TaskManager 部署架构

```
┌─────────────────────────────────────────────────────┐
│               边缘服务器（一台物理机）                │
├─────────────────────────────────────────────────────┤
│                                                     │
│  TaskManager (HTTP :8080)                          │
│  ├─ Task-camera_001 (RTSP → AI → RTMP)            │
│  ├─ Task-camera_002 (RTSP → AI → RTMP)            │
│  ├─ Task-camera_003 (RTSP → AI → RTMP)            │
│  ├─ ...                                             │
│  └─ Task-camera_050 (RTSP → AI → RTMP)            │
│                                                     │
│  ZLMediaKit (RTMP服务器 :1935)                     │
│  ├─ Stream: live/camera_001                        │
│  ├─ Stream: live/camera_002                        │
│  └─ ...                                            │
│                                                     │
│  PostgreSQL (本地数据库)                           │
│  └─ 存储任务配置、模型信息、报警记录               │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

### 阶段2：模型动态管理 ⭐⭐⭐⭐

**目标**：支持模型热更新和多模型切换

#### 2.1 模型管理API

```cpp
// TaskManager HTTP API扩展
POST   /api/models/upload        # 上传模型文件
GET    /api/models               # 列出所有可用模型
POST   /api/tasks/{id}/model     # 切换任务使用的模型
DELETE /api/models/{model_id}    # 删除模型
```

#### 2.2 模型存储结构

```
/models/
  ├── yolov11n.onnx           # 轻量模型（通用）
  ├── yolov11s.onnx           # 小模型
  ├── helmet_detection.onnx   # 安全帽检测专用模型
  ├── fire_smoke.onnx         # 火焰烟雾检测
  └── classes/
      ├── coco.names           # COCO类别
      ├── helmet.names         # 安全帽类别
      └── fire.names           # 火焰类别
```

#### 2.3 模型热更新流程

```
1. 云端训练新模型
   └─> 导出ONNX格式
   └─> 存储到MinIO

2. 通过TaskManager API上传模型
   └─> POST /api/models/upload
   └─> 边缘TaskManager保存到本地/models/

3. 更新任务使用的模型
   └─> POST /api/tasks/{id}/model {"model_path": "new_model.onnx"}
   └─> TaskManager停止任务 → 重新加载模型 → 重启任务
```

---

### 阶段3：报警区域检测（ROI）⭐⭐⭐

**目标**：只在指定区域触发报警

#### 3.1 区域配置格式

```json
{
  "task_id": "camera_001",
  "alarm": {
    "enable": true,
    "confidence_threshold": 0.5,
    "regions": [
      {
        "name": "入口区域",
        "polygon": [
          [100, 200],
          [500, 200],
          [500, 600],
          [100, 600]
        ],
        "classes": ["person"],  // 只检测人
        "action": "alert"
      },
      {
        "name": "禁区",
        "polygon": [
          [600, 100],
          [900, 100],
          [900, 400],
          [600, 400]
        ],
        "classes": ["person", "vehicle"],
        "action": "alert"
      }
    ]
  }
}
```

#### 3.2 实现步骤

1. 定义 `AlarmRegion` 结构体
2. 实现点在多边形内判断算法（射线法）
3. 在检测结果过滤时应用区域筛选
4. 前端绘制区域工具（已有基础）

---

### 阶段4：前端集成（视频墙）⭐⭐⭐⭐

**目标**：统一展示50路视频流

#### 4.1 视频墙架构

```vue
<!-- WEB/src/views/monitor/VideoWall.vue -->
<template>
  <div class="video-wall">
    <div v-for="camera in cameras" :key="camera.id" class="video-item">
      <video-player
        :stream-url="`http://localhost/live/${camera.id}.flv`"
        :camera-name="camera.name"
        @alarm="handleAlarm"
      />
      <div class="camera-status">
        <Tag :color="camera.status === 'active' ? 'green' : 'red'">
          {{ camera.status }}
        </Tag>
      </div>
    </div>
  </div>
</template>
```

#### 4.2 API集成

```typescript
// WEB/src/api/task/index.ts
export const taskApi = {
  // 任务管理
  createTask: (config) => post('/edge/tasks', config),
  listTasks: () => get('/edge/tasks'),
  startTask: (id) => post(`/edge/tasks/${id}/start`),
  stopTask: (id) => post(`/edge/tasks/${id}/stop`),
  getTaskStatus: (id) => get(`/edge/tasks/${id}/status`),
  
  // 模型管理
  uploadModel: (file) => upload('/edge/models', file),
  listModels: () => get('/edge/models'),
  switchModel: (taskId, modelId) => post(`/edge/tasks/${taskId}/model`, { modelId })
}
```

---

### 阶段5：离线部署优化 ⭐⭐⭐

**目标**：支持完全离线运行

#### 5.1 本地化数据库

```sql
-- 使用SQLite替代PostgreSQL（可选）
CREATE TABLE tasks (
    id TEXT PRIMARY KEY,
    config TEXT NOT NULL,
    status TEXT DEFAULT 'stopped',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE models (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    path TEXT NOT NULL,
    version TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE alarms (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    class TEXT,
    confidence REAL,
    image_path TEXT,
    FOREIGN KEY (task_id) REFERENCES tasks(id)
);
```

#### 5.2 本地Web控制台

```
┌───────────────────────────────────────┐
│      TaskManager Local Console        │
│      http://192.168.1.100:8080        │
├───────────────────────────────────────┤
│                                       │
│  📹 视频墙 (50路实时视频)             │
│  ⚙️  任务管理 (启动/停止/配置)        │
│  🤖 模型管理 (上传/切换)              │
│  🚨 报警记录 (历史查询)               │
│  📊 性能监控 (CPU/内存/推理耗时)      │
│                                       │
└───────────────────────────────────────┘
```

---

## 📐 五、50路摄像头部署架构设计

### 5.1 单机部署方案（推荐）

**硬件配置建议**：
- CPU: Intel i7-12700 (12核) 或 AMD Ryzen 7 5800X
- 内存: 64GB DDR4
- GPU: NVIDIA RTX 3060 (12GB显存) 或 RTX 4060
- 存储: 2TB NVMe SSD
- 网络: 双千兆网卡（一个接摄像头，一个接外网）

**软件架构**：

```
┌─────────────────────────────────────────────────────────────┐
│                    边缘AI推理服务器                         │
│                 (192.168.1.100 - 内网IP)                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  TaskManager (:8080)                                        │
│  ├─ 管理50个推理任务                                        │
│  ├─ HTTP API (本地Web控制台)                               │
│  └─ SQLite本地数据库                                        │
│                                                             │
│  ZLMediaKit (:1935/:80)                                     │
│  └─ 接收50路RTMP推流                                        │
│                                                             │
│  TASK Processes (50个实例)                                  │
│  ├─ camera_001: RTSP → YOLOv11 → RTMP (:1.5GB内存)        │
│  ├─ camera_002: RTSP → YOLOv11 → RTMP (:1.5GB内存)        │
│  ├─ ...                                                     │
│  └─ camera_050: RTSP → YOLOv11 → RTMP (:1.5GB内存)        │
│                                                             │
│  资源占用估算:                                              │
│  ├─ 内存: 50 × 1.5GB = 75GB (建议64GB + 交换)            │
│  ├─ CPU: 50路 @ 25fps,每路10-15% CPU = 需要12核+         │
│  └─ 带宽: 50 × 4Mbps (RTSP) + 50 × 2Mbps (RTMP) = 300Mbps │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 多机分布式方案（备选）

如果单机性能不足，可以部署2-3台服务器：

```
服务器1 (192.168.1.101) - 20路摄像头
服务器2 (192.168.1.102) - 20路摄像头
服务器3 (192.168.1.103) - 10路摄像头

┌─────────────────────────────────────────┐
│       主控服务器 (192.168.1.100)        │
│                                         │
│  TaskManager Master (:8080)             │
│  ├─ 负载均衡                            │
│  ├─ 任务调度                            │
│  └─ 统一Web控制台                       │
│                                         │
│  ZLMediaKit (:1935)                     │
│  └─ 汇聚所有视频流                      │
└─────────────────────────────────────────┘
           │
    ┌──────┼──────┐
    │      │      │
┌───▼──┐ ┌─▼────┐ ┌─▼────┐
│ 101  │ │ 102  │ │ 103  │
│ 20路 │ │ 20路 │ │ 10路 │
└──────┘ └──────┘ └──────┘
```

---

## 🚀 六、立即行动计划

### Week 1-2: TaskManager核心框架
1. ✅ 集成 cpp-httplib（HTTP服务器）
2. ✅ 实现任务创建/启动/停止API
3. ✅ 实现任务配置的JSON解析
4. ✅ 多任务并发管理

### Week 3: 模型管理
1. ✅ 实现模型上传API
2. ✅ 实现模型热更新机制
3. ✅ 支持多模型切换

### Week 4: 报警区域
1. ✅ ROI多边形定义
2. ✅ 点在多边形判断算法
3. ✅ 集成到报警逻辑

### Week 5-6: 前端集成
1. ✅ 视频墙UI组件
2. ✅ TaskManager API对接
3. ✅ 实时状态监控

### Week 7: 性能优化
1. ✅ 内存优化（减少泄漏）
2. ✅ 多线程优化
3. ✅ GPU加速（可选）

### Week 8: 测试与部署
1. ✅ 50路并发压力测试
2. ✅ 离线部署验证
3. ✅ 文档完善

---

## 📝 七、关键技术决策

### 7.1 为什么需要 TaskManager？

| 决策 | 理由 |
|------|------|
| 统一进程管理 | 50路摄像头不能手动启动50个TASK.exe |
| HTTP API | 方便前端/云端远程管理 |
| JSON配置 | 比INI更灵活，支持动态更新 |
| 心跳上报 | 监控任务健康状态 |

### 7.2 为什么不用云端Python推理？

| 对比项 | Python (AI模块) | C++ (TASK模块) |
|-------|-----------------|----------------|
| 性能 | 较慢 | ✅ 快3-5倍 |
| 内存 | 每路~3GB | ✅ 每路~1.5GB |
| 延迟 | 2-3秒 | ✅ <1秒 |
| 并发 | 10路即吃力 | ✅ 50路无压力 |
| 部署 | 需要Python环境 | ✅ 单个exe |
| 离线 | 需要网络 | ✅ 完全离线 |

**结论**：边缘50路并发，必须用C++ TASK模块！

---

## 🎯 八、你的下一步

### 立即可以做的：

1. **确认硬件配置**
   - 你的边缘服务器硬件是什么？
   - 能不能支持50路并发？

2. **确认网络拓扑**
   - 50个摄像头的IP段是什么？
   - 是否需要连接外网？

3. **选择开发方案**
   - 方案A：我帮你完整实现TaskManager（推荐）
   - 方案B：你自己实现，我提供指导

### 我可以立即帮你做的：

1. ✅ 实现TaskManager HTTP API
2. ✅ 实现多任务管理器
3. ✅ 实现报警区域检测
4. ✅ 实现模型热更新
5. ✅ 提供完整的部署文档

---

## 💬 现在请告诉我：

1. **你想先做哪个？**
   - A. TaskManager（让TASK支持API管理）⭐⭐⭐⭐⭐
   - B. 报警区域检测（ROI过滤）⭐⭐⭐
   - C. 前端视频墙集成⭐⭐⭐⭐
   - D. 模型管理优化⭐⭐⭐⭐

2. **你的边缘服务器配置是什么？**
   - CPU型号？
   - 内存大小？
   - 是否有GPU？

3. **摄像头信息？**
   - 分辨率？
   - 帧率？
   - IP地址段？

**我建议先做 TaskManager（选项A），这是云边协同的核心，也是50路并发的基础！**

要开始吗？🚀

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 